Онлайн обновление ленты новостей
Цель:
Разработать WebSocket сервер, при помощи которого подключенные клиенты будут сразу получать обновления постов своих друзей. Такой подход позволит сэкономить ресурсы и обновлять молниеносно ленты активных клиентов.
 
Описание/Пошаговая инструкция выполнения домашнего задания:

**1) Реализовать REST API:**
- Создание поста (метод `/post/create` из [спецификации](https://github.com/OtusTeam/highload/blob/master/homework/openapi.json "спецификации"))
**2) Реализовать асинхронное API с websocket:**
- [https://app.swaggerhub.com/apis-docs/AVPGENIUM_1/otus-highload_architect_async/1.0.0](https://app.swaggerhub.com/apis-docs/AVPGENIUM_1/otus-highload_architect_async/1.0.0 "https://app.swaggerhub.com/apis-docs/AVPGENIUM_1/otus-highload_architect_async/1.0.0")
- Реализовать отправку сообщений в канал `/post/feed/posted` через websocket согласно [спецификации](https://github.com/OtusTeam/highload/blob/master/homework/asyncapi.json "спецификации")
- **Требования**: при добавлении нового поста друга подписчику websocket'а должно приходить событие о новом посте, тем самым обеспечивая обновление ленты в реальном времени
**4) Реализовать отложенную материализацию ленты:**  
Требования

- Формирование лент работает через очередь (отложено)
- при реализации обязательно обеспечить отправку только целевым пользователям это событие (можно применить Routing Key из RabbitMQ)

**5) (Опционально) Формирование ленты производить через постановку задачи в очередь на часть друзей, чтобы избежать "эффекта Леди Гаги"/celebrity** (один пользователь пишет сильно больше среднего)
    *Что такое "эффект Леди Гаги"?*
    Когда один пользователь пишет сильно больше среднего (поэтому такое название). На примере twitter, есть селебрити, посты которых читает огромное кол-во человек. можно взять подход twitter - пользователи делятся на селебрити и обычных. Для селебрити они просто добавляют посты, для обычных - добавляют посты и обновляют ленту

---

  
**Форма сдачи ДЗ**

- Предоставить ссылку на исходный код (github, gitlab, etc)
- Предоставить докеризированное приложение, которое можно запустить при помощи docker-compose (может лежать рядом с исходным кодом) ИЛИ развернутое приложение, доступное извне ИЛИ инструкция по запуску

  

Критерии оценки:

Оценка происходит по принципу зачет/незачет.  
Требования:

1. При добавлении поста у друга, лента должна обновляться автоматически (с небольшой задержкой).
2. Корректная работа сервиса вебсокетов.
3. Линейная масштабируемость сервиса вебсокетов.
4. Описан процесс масштабирования Kafka / Rabbit MQ.

  

Компетенции:

- Асинхронная обработка
    - - использовать брокеры сообщений RabbitMQ, kafka
    - - проектировать event-driven архитектуры
    - - применять маршрутизации и фильтрации сообщений
    - - применять WebSockets

## Архитектурная проработка
Принято решение не отклоняться от курса, выбранного в прошлой домашней работе. Дублирую здесь выбранное решение.
### Выбранный вариант (адаптация под Websocket)

Для high load приложения выбран подход, при котором микросервис делегирует проверку авторизации монолиту. Монолит выполняет проверку JWT (подпись и черный список) и передает микросервису идентификатор пользователя через адресную строку (`ws://` ). Это решение минимизирует нагрузку на микросервис, устраняет необходимость повторной проверки токена и позволяет сосредоточиться на бизнес-логике.

### Архитектура решения
Архитектура текущего решения (с акцентом на поставленную задачу) представлена на [рисунке 1](./hw6-architecture-1.png). **Компонент API** отвечает за обслуживание HTTP запросов. Он отвечает за обработку HTTP запросов, в т.ч.: 
	- `POST /api/post` - создать новый пост;
	- `GET /api/post/{post_id}` - получить пост (по идентификатору);
	- `PUT /api/post/{post_id}` - отредактировать пост (по идентификатору);
	- `DELETE /api/post/{post_id}` - удалить пост (по идентификатору);
	- `GET /api/post/feed` - получить ленту новостей.
После сохранения поста в БД (только для запросов POST, PUT, DELETE) выполняется отправка информации о выполненной операции в топик `post-modified`.
**Компонент NotifyFollowers** выполняет две функции:
- мультиплексирование и фильтрацию сообщений из топика `post-modified` в топики `feed-changed`, `follower-notify`;
- защиту от "эффекта Леди Гаги": если у пользователя слишком много подписчиков, то нагрузка на формирование оповещений распределяется между всеми экземплярами компонента (путем отправки специальных сообщений в топик `post-modified`).
**Компонент Websocket Notifier** отвечает за обслуживание Websocket-запросов. Он подписан на топик `follower-notify` и пересылает сообщения пользователям, которых он обслуживает.
**Компонент Cache Invalidator** отвечает за инвалидацию кеша активных пользователей. Для таких пользователей лента новостей будет построена заново и сохранена в Redis.


![[hw6-architecture-1.png]]

Предложенное решение имеет один недостаток: хоть горизонтальное масштабирование Websocket Notifier предусмотрено, но оно ограничено, т.к. каждый экземпляр сервиса вынужден читать все сообщения из топика. Когда-нибудь закончится сетевой интерфейс. С другой стороны, это не кажется проблемой, т.к. намного раньше у сервера закончатся ресурсы сервера на обработку постоянно открытых соединений Websocket.
Архитектура строилась исходя их того, что это не является проблемой, т.к. сейчас на рынке доступны сетевые интерфейсы 10 гбит/с и более, таким образом теоретическим пределом будет в районе 1-2 млн сообщений в секунду.
Для снятия этого ограничения можно управляемо распределить клиентов по экземплярам компонента Websocket Notifier, используя значение UserId. Такое решение представлено на [рисунке 2](./hw6-architecture-2.png). 

![[hw6-architecture-2.png]]

## Как запустить проект

```bash

git clone https://github.com/Vasiliy82/otus-hla-homework.git
cd otus-hla-homework/environments/hw06
make up

# открыть макет в браузере http://localhost:8080
# можно открыть несколько окон и авторизоваться под двумя тестовыми пользователями:
# 1) johndoe@gmail.com   :   password123
# 2) masha@gmail.com     :   password123
#
# 

# почистить за собой
make destroy
```

Как пользоваться тестовой формой:
1. Ввести логин и пароль тестового пользователя;
2. Нажать Авторизация;
3. Нажать Connect для подключения к Websocket;
4. С этого момента если ДРУГОЙ тестовый пользователь создаст или отредактирует пост, запись об этом появится в окне лога;
5. Текущий пользователь также может создать новый пост прямо из формы, для этого нужно заполнить поле Сообщение и нажать кнопку Отправить.

Результаты тестирования на [скриншоте](./screen.png)

![[screen.png]]'
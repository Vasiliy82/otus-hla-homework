# ДЗ №4. Отчет о проделанной работе

## 1. Постановка задачи
Лента постов от друзей
Цель:
В результате выполнения ДЗ вы создадите ленту постов друзей социальной сети  
В данном задании тренируются навыки:
- работа с кешами;
- работа с очередями;
- проектирование масштабируемых архитектур.
Описание/Пошаговая инструкция выполнения домашнего задания:
**1) Реализовать API (синхронный rest)**
- (опционально) Добавление/удаление друга (методы _/friend/add_, _/friend/delete_ из [спецификации](https://github.com/OtusTeam/highload/blob/master/homework/openapi.json "спецификации"))
- (опционально) CRUD для постов пользователей (методы _/post/create_, _/post/update_, _/post/delete_, _/post/get_ из [спецификации](https://github.com/OtusTeam/highload/blob/master/homework/openapi.json "спецификации"))
- Лента постов друзей (метод _/post/feed_ из [спецификации](https://github.com/OtusTeam/highload/blob/master/homework/openapi.json "спецификации"))
---
**2) Разработать структуру БД для хранения постов пользователей.**  
Наполнить БД тестовыми данными.  
ссылка на сгенерированные тексты постов: [https://github.com/OtusTeam/highload/blob/master/homework/posts.txt](https://github.com/OtusTeam/highload/blob/master/homework/posts.txt "https://github.com/OtusTeam/highload/blob/master/homework/posts.txt")  
(опционально, можно сгенерировать самостоятельно)

---
**3) Реализовать кэширование ленты.**  
Требования:
- Лента постов друзей формируется на уровне кешей
- В ленте держать последние 1000 обновлений друзей
- Лента должна кешироваться

---
**  
Дополнительные материалы**  
Инструкция к ДЗ также доступна по [ссылке](https://otusmetodist.yonote.ru/share/94ee610e-2e76-4e80-93fc-ad74fe04e8d4/doc/homework-4-lenta-postov-ot-druzej-taoWO1XJvF "ссылке").

---
**  
Форма сдачи ДЗ**
1. Предоставить ссылку на исходный код (github, gitlab, etc)
2. Предоставить докеризированное приложение, которое можно запустить при помощи docker-compose (может лежать рядом с исходным кодом) ИЛИ развернутое приложение, доступное извне
Критерии оценки:
Оценка происходит по принципу зачет/незачет.  
Требования:
1. Верно работает инвалидация кеша.
2. (опционально) Обновление лент работает через очередь.
3. Есть возможность перестройки кешей из СУБД.
Компетенции:
- In-Memory вычисления
- использовать кэширование
## 2. Концептуальный дизайн

| #   | Компонент          | Стек технологий | Описание                                                                        |
| --- | ------------------ | --------------- | ------------------------------------------------------------------------------- |
| 1   | СУБД               | Postgresql 17   | Хранилище данных                                                                |
| 2   | Приложение         | Go              | Приложение, реализующее бизнес-логику (фронтенд, бекенд). Архитектура - монолит |
| 3   | Кеш ленты          | Redis           | Хранилище кеша ленты                                                            |
| 4   | Очередь кеша ленты | Kafka           | Очереди для событий асинхронной инвалидации кеша ленты                          |
|     |                    |                 |                                                                                 |
## 3. Реализация недостающих endpoints
Доработка реализована в [коммите](https://github.com/Vasiliy82/otus-hla-homework/commit/7a24a5cd145341929b9d4f2ac399206fd7e78f20)

Краткое описание изменений:
На основе изученного содержимого файла, вот краткое описание изменений, сделанных в коммите:
- **Доменные сущности:**
    - Добавлена сущность `domain.UserLastActivity`, представляющая дату и время последней активности пользователей.
- **Репозитории:**
    - В `UserRepository` добавлены новые методы:
        - `GetFriendsIds(id UserKey) ([]UserKey, error)` — получение списка идентификаторов друзей пользователя.
        - `SetLastActivity(id UserKey) error` — запись времени последней активности пользователя.
        - `GetUsersActiveSince(period time.Duration) ([]UserKey, error)` — получение пользователей, активных за указанный временной промежуток.
- **Middleware:**
    - Добавлен middleware для обновления активности пользователей `UserActivityMiddleware`. Он извлекает `user_id` из контекста и обновляет последнюю активность в базе данных.
- **Добавлено кеширование**
    - [Интерфейс](https://github.com/Vasiliy82/otus-hla-homework/blob/7a24a5cd145341929b9d4f2ac399206fd7e78f20/backend/domain/interfaces.go#L36)
    - Реализованы методы работы с кешом: [GetFeed](https://github.com/Vasiliy82/otus-hla-homework/blob/7a24a5cd145341929b9d4f2ac399206fd7e78f20/backend/internal/repository/cache/post.go#L26) , [UpdateFeed](https://github.com/Vasiliy82/otus-hla-homework/blob/7a24a5cd145341929b9d4f2ac399206fd7e78f20/backend/internal/repository/cache/post.go#L57), 
    - Реализована инвалидация кеша: сервис [CacheInvalidator](https://github.com/Vasiliy82/otus-hla-homework/blob/7a24a5cd145341929b9d4f2ac399206fd7e78f20/backend/internal/services/cache_invalidator.go#L17)
- **Интеграция с Kafka:**
    - Добавлена отправка событий об обновлении кеша активных пользователей в Kafka через продюсер.
- **Прогрев кеша:**
    - Реализован механизм прогрева кеша для активных пользователей с использованием методов репозитория и отправкой событий в Kafka. Реализация: [CacheWarmup](https://github.com/Vasiliy82/otus-hla-homework/blob/7a24a5cd145341929b9d4f2ac399206fd7e78f20/backend/internal/services/cache_invalidator.go#L195C28-L195C39)
- **Рефакторинг:**
    - Улучшена структура кода, добавлены комментарии и обработка ошибок для повышения устойчивости и читаемости.
### 4. Немного критики. Почему Redis - не лучший выбор для высоконагруженной социальной сети?
1. **Кэш на диске дешевле, чем в памяти**:
При миллионах пользователей и миллиардах постов хранение кеша на диске (например, с использованием Tarantool, MongoDb) более экономично, чем в памяти. Это позволяет сократить затраты на инфраструктуру и масштабирование.
2. **Отклик важен, но цена важнее**:
Отклик хранилища ключ-значение будет составлять **20-40 мс**, в то время как для кеша в памяти (например, Redis) время отклика может достигать **1-5 мс**. Важно отметить, что разница в 35 мс вполне приемлема для пользователей социальной сети, с учетом того, что это позволяет кратно снизить затраты на оборудование.
3. **Экономия ресурсов**:
При высокой активности пользователей, использование дискового кэша позволит более эффективно управлять ресурсами, чем хранение данных в памяти. Это становится особенно актуально при росте количества пользователей, когда объемы данных становятся огромными.